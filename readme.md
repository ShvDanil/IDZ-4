# Архитектура вычислительных систем

## Индивидуальное домашнее задание №4

### Швецов Данил Игоревич, БПИ219

#### Вариант 5
Задание: Задача об обедающих философах. 

Пять философов сидят возле круглого стола. Они проводят жизнь, чередуя приемы пищи и размышления. В центре стола находится большое блюдо спагетти. Спагетти длинные и запутанные, философам тяжело управляться с ними, поэтому каждый из них, чтобы съесть порцию, должен пользоваться двумя вилками. К несчастью, философам дали только пять вилок. Между каждой парой философов лежит одна вилка, поэтому эти высококультурные и предельно вежливые люди договорились, что каждый будет пользоваться только теми вилками, которые лежат рядом с ним (слева и справа). Написать многопоточную программу, моделирующую поведение философов с помощью семафоров. Программа должна избегать фатальной ситуации, в которой все философы голодны, но ни один из них не может взять обе вилки (например, каждый из философов держит по одной вилке и не хочет отдавать ее). Решение должно быть симметричным, то есть все потоки-философы должны выполнять один и тот же код.

## Отчет

### Данное индивидуальное домашнее задание выполнено на оценку 6.

#### Проблематика

Перед тем как перейти к формализации задачи, описанию сущностей и подробной информации об используемом алгоритме, в котором будет показано, как на программу отображается каждый из субъектов предметной области, предлагаю рассмотреть общую проблематику задачи об обедающих философах и разобраться, в чем кроется ее суть.

Чтобы не ходить далеко, рассмотрим описание проблематики задачи на Википедии по следующей ссылке: https://ru.wikipedia.org/wiki/Задача_об_обедающих_философах.

Внимательно прочитав информацию в начале раздела "Проблемы", можно понять, что задача должна состоять в том, чтобы найти решение проблемы взаимной блокировки, то есть дедлока (с англ. deadlock) - такого состояния, когда прогресс невозможен. Далее происходит размышление о возможном алгоритме решения задачи, который первым приходит в голову (и он тоже описан на Википедии):
* размышлять, пока не освободится левая вилка. Когда вилка освободится — взять её;
* размышлять, пока не освободится правая вилка. Когда вилка освободится — взять её;
* есть;
* положить левую вилку;
* положить правую вилку;
* повторить алгоритм сначала.

Однако в таком решении есть проблема: оно некорректно. Глобально некорректность проявляется в возможности у системы достичь состояния взаимной блокировки, например, когда каждый философ взял вилку слева и ждёт, когда вилка справа освободится.

Главными же проблемами являются
* проблема ресурсного голодания;
* проблема взаимного исключения.

Как наглядно описать их возникновение в рамках условия задачи?

Начнем с первой. Она может проявляться вне зависимости от взаимной блокировки ресурсов: так, один из философов не может завладеть левой и правой вилкой из-за проблем синхронизации. Например, пусть имеется правило, которое гласит, что философы возвращают вилку на стол через каждые t секунд, проведенных в ожидании доступности другой вилки. А потом еще ждут t секунд перед следующей попыткой завладеть вилками. Проблема блокировки решается. А вот что, если все философы сядут за стол одновременно и возьмут по левой вилке в одно и то же время? Они, положив левую вилку на стол и надеясь заполучить правую, будут вновь ждать t секунд, не совершая полезной работы, из-за чего возникает ситуация зацикливания системы: изменяется состояние, но не совершается никакая полезная работа.

Теперь же перейдем ко второй проблеме. Ее достаточно легко и логично вписать в рамки задачи: нескольким объектам (в нашем случае - философам) требуется исключительный доступ к совместно используемым ресурсам (в нашем случае - к левой и правой вилкам).

#### Формализация

Выяснив все проблемы, подробно описанные выше, мы плавно подходим к вопросу: как же решить их? В задании предлагается использование семафоров, поэтому перейдем к более формальному разговору о поставленной задаче.

Для начала разберемся с необходимым синхропримитивом для организации согласованного взаимодействия потоков. Прочитаем статью про использование семафоров на Википедии по ссылке: https://ru.wikipedia.org/wiki/Семафор_(программирование) и небольшую статью на хабре для большего понимания темы по ссылке: https://habr.com/ru/post/476940/.

Решение данной задачи с помощью семафоров достигается путем добавления сущности "Официант" возле стола (данный пример описан на Википедии). Что представляет из себя данная сущность? Официант - массив семафоров-вилок. Работа осуществляется по типу частного случая семафоров-мьютексов: каждая вилка имеет 2 состояния (используется / не используется) + ресурс может быть использован одновременно только одним потоком (поток - это философ). 

Что представляет из себя алгоритм? Философы должны ожидать разрешение официанта, чтобы взять вилку со стола. Так как у официанта есть информация о количестве используемых вилок в текущий момент времени, он может грамотно и правильно распределять ресурсы (вилки), тем самым предотвращая взаимную блокировку философов. Если же задействованы четыре из пяти вилок, то следующий философ, которому потребуется вилка, будет вынужден дождаться разрешения официанта. Официант же не даст разрешения взять вилку до тех пор, пока вилка не будет освобождена. Примечание с Википедии: предполагается, что философ всегда пытается сначала взять левую вилку, а потом — правую (или наоборот), что упрощает логику.

Как работает решение? Обозначим философов по часовой стрелке цифрами от 1 до 5. Если едят философы 1 и 3, то заняты четыре вилки. Философ 2 расположен между 1 и 3, соответственно, им не используется ни одна вилка, так как обе заняты. Философы 4 и 5 имеют доступ к одной не задействованной другими вилке, находящейся между ними. Если философ 5 захочет есть и сразу же возьмет свободную вилку, то появляется возможность взаимной блокировки философов. Когда есть официант, регулирующий распределение вилок между философами, то вместо того, чтобы занять вилку сразу, философ уточнит ее "состояние" у официанта, который в свою очередь попросит подождать. Так можно быть уверенным, как только освободится пара вилок, один философ сможет взять две вилки. Взаимная блокировка ресурсов не произойдет, что и требовалось.

#### Решение

Для написания консольного приложения с использованием библиотеки POSIX Threads был использован язык программирования C++. Были задействованы библиотеки "semaphore.h" и "pthread.h". (Следующие 2 предложения верно лишь для закомментированного кода, так как в чате написали, что лучше не вводить ограничений на число итераций поедания) Для того, чтобы время работы не было бесконечным, пользователю предлагается ввести через консоль количество итераций поедания спагетти философами. Также есть небольшие ограничения на диапазон [1; 100] для того, чтобы были введены числа в разумных пределах.

Основной метод работает следующим образом: философы-потоки размышляют 3 секунды. Затем они пытаются взять вилку слева от них. Если получилось это сделать, то и вилку справа от них. Необходимость семафора заключается в том, что он контролирует процесс занятости вилок и заставляет ждать, если на данный момент вилка занята другим философом-потоком. То есть когда философ-семафор берет вилку, он начинает ожидание, блокируя вилку для остальных потоков до тех пор, пока она вновь не будет возвращена на стол. Затем философ ест в течение 2 секунд, возвращает вилку на стол и вновь размышляет 3 секунды.

В основной функции main инициализируются вилки-семафоры, мьютекс, затем создаются потоки-философы, и запускается программа для 5 потоков-философов с их последующим объединением.

#### Тестирование программы

Запустим программу и проверим ее работоспособность при бесконечных итерациях поедания спагетти. Убедимся в корректности работоспособности программы, посмотрев на видео ее выполнения ниже. Завершим выполнение программы с помощью сочетания клавиш Ctrl + C.





